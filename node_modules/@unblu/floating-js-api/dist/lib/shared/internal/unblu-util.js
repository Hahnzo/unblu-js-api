// Typedef Helpers
/**
 * @hidden
 */
import { ApiState } from "../api-state";
import { UnbluApiError, UnbluErrorType } from "../unblu-api-error";
export var IntegrationType;
(function (IntegrationType) {
    IntegrationType["embedded"] = "embedded";
    IntegrationType["floating"] = "floating";
})(IntegrationType || (IntegrationType = {}));
var EntryPoint;
(function (EntryPoint) {
    EntryPoint["siteIntegrationGreedyMain"] = "SiteIntegrationGreedyMain";
    EntryPoint["siteIntegrationLazyMain"] = "SiteIntegrationLazyMain";
    EntryPoint["siteEmbeddedMain"] = "SiteEmbeddedMain";
})(EntryPoint || (EntryPoint = {}));
class NamedAreaMetaTag extends Element {
}
export class UnbluUtil {
    static async loadScript(uri, timeout) {
        const timeoutTime = timeout || 30000;
        const script = document.createElement('script');
        script.setAttribute('charset', 'UTF-8');
        script.setAttribute('type', 'text/javascript');
        script.setAttribute('async', 'true');
        script.setAttribute('timeout', timeoutTime.toString());
        script.src = uri;
        return new Promise(function (resolve, reject) {
            let timeoutId;
            const cleanup = () => {
                // avoid mem leaks in IE.
                script.onerror = script.onload = null;
                window.clearTimeout(timeoutId);
            };
            const onError = (error) => {
                cleanup();
                console.error('Failed to load script! Uri:', uri, 'Error:', error);
                reject(error);
            };
            script.onload = () => {
                cleanup();
                resolve();
            };
            script.onerror = onError;
            timeoutId = window.setTimeout(() => onError('Timeout'), timeoutTime);
            const head = document.getElementsByTagName('HEAD')[0];
            head.appendChild(script);
        });
    }
    static getNamedArea() {
        const existingMetaTag = window.document.querySelector('meta[name="unblu:named-area"]');
        return existingMetaTag ? existingMetaTag.getAttribute('content') : undefined;
    }
    static setNamedArea(namedArea) {
        const existingMetaTag = window.document.querySelector('meta[name="unblu:named-area"]');
        if (existingMetaTag && !existingMetaTag.originalContent) {
            existingMetaTag.originalContent = existingMetaTag.getAttribute('content');
        }
        const metaTag = existingMetaTag || window.document.createElement('meta');
        metaTag.setAttribute('name', 'unblu:named-area');
        metaTag.setAttribute('content', namedArea);
        if (!metaTag.parentElement) {
            window.document.head.appendChild(metaTag);
        }
    }
    static removeNamedArea() {
        const metaTag = window.document.querySelector('meta[name="unblu:named-area"]');
        if (metaTag === null || metaTag === void 0 ? void 0 : metaTag.originalContent) {
            metaTag.setAttribute('content', metaTag.originalContent);
            metaTag.originalContent = null;
        }
        else if (metaTag) {
            metaTag.remove();
        }
    }
    static setLocale(locale) {
        // unblu.l will be read in user-locale-util.js
        UnbluUtil.getUnbluObject().l = locale;
    }
    static async loginWithSecureToken(serverUrl, apiKey, entryPath, accessToken) {
        const url = `${serverUrl}${entryPath}/rest/v3/authenticator/loginWithSecureToken?x-unblu-apikey=${apiKey}`;
        let response;
        try {
            response = await fetch(url, {
                method: 'POST',
                mode: 'cors',
                cache: 'no-cache',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json'
                },
                redirect: 'follow',
                body: JSON.stringify({
                    token: accessToken,
                    type: 'JWT'
                })
            });
        }
        catch (e) {
            throw new UnbluApiError(UnbluErrorType.AUTHENTICATION_FAILED, `Failed to authenticate with provided access token! Reason: ${e}`);
        }
        if (!response.ok) {
            throw new UnbluApiError(UnbluErrorType.AUTHENTICATION_FAILED, `Failed to authenticate with provided access token! Status: ${response.status}; StatusText: ${response.statusText}`);
        }
    }
    static async isAuthenticated(serverUrl, entryPath) {
        const url = `${serverUrl}${entryPath}/rest/v3/authenticator/isAuthenticated`;
        let response;
        try {
            response = await fetch(url, {
                method: 'GET',
                mode: 'cors',
                cache: 'no-cache',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json'
                },
                redirect: 'follow',
            });
        }
        catch (e) {
            throw new UnbluApiError(UnbluErrorType.AUTHENTICATION_FAILED, `Failed to check if authenticated! Reason: ${e}`);
        }
        if (!response.ok) {
            throw new UnbluApiError(UnbluErrorType.AUTHENTICATION_FAILED, `Failed to check if authenticated! Status: ${response.status}; StatusText: ${response.statusText}`);
        }
        return true === await response.json();
    }
    static async logout(serverUrl, entryPath) {
        const url = `${serverUrl}${entryPath}/rest/v3/authenticator/logout`;
        let response;
        try {
            response = await fetch(url, {
                method: 'POST',
                mode: 'cors',
                cache: 'no-cache',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json'
                },
                redirect: 'follow',
                body: ''
            });
        }
        catch (e) {
            throw new UnbluApiError(UnbluErrorType.AUTHENTICATION_FAILED, `Failed to logout! Reason: ${e}`);
        }
        if (!response.ok) {
            throw new UnbluApiError(UnbluErrorType.AUTHENTICATION_FAILED, `Failed to logout! Status: ${response.status}; StatusText: ${response.statusText}`);
        }
    }
    static isUnbluLoaded(integrationType) {
        return UnbluUtil.getUnbluObject() && !!UnbluUtil.getUnbluObject().APIKEY && UnbluUtil.entryPointMatches(integrationType);
    }
    static generateConfigurationFromLoadedUnblu() {
        const unblu = UnbluUtil.getUnbluObject();
        // @ts-ignore
        const unbluInternal = window[unblu.globalPrefix];
        return {
            apiKey: unblu.APIKEY,
            serverUrl: unblu.SERVER,
            entryPath: unbluInternal === null || unbluInternal === void 0 ? void 0 : unbluInternal.$_baseCfg.entryPath,
            locale: unblu.l,
            namedArea: UnbluUtil.getNamedArea()
        };
    }
    static entryPointMatches(integrationType) {
        if (integrationType === IntegrationType.embedded) {
            return UnbluUtil.getUnbluObject().entryPoint === EntryPoint.siteEmbeddedMain;
        }
        else if (integrationType === IntegrationType.floating) {
            return UnbluUtil.getUnbluObject().entryPoint === EntryPoint.siteIntegrationGreedyMain || UnbluUtil.getUnbluObject().entryPoint === EntryPoint.siteIntegrationLazyMain;
        }
        else {
            return false;
        }
    }
    static getUnbluObject() {
        // @ts-ignore
        return window.unblu;
    }
    static createUnbluObject() {
        // @ts-ignore
        return window.unblu = {};
    }
    static getOrCreateUnbluObject() {
        // @ts-ignore
        return window.unblu || (window.unblu = {});
    }
    static async deinitializeFloatingIfNeeded() {
        if (!UnbluUtil.isUnbluLoaded(IntegrationType.floating)) {
            return;
        }
        const apiState = UnbluUtil.getUnbluObject().floating.api.getApiState();
        let unbluApi;
        if (apiState == ApiState.INITIALIZING || apiState == ApiState.INITIALIZED) {
            unbluApi = await UnbluUtil.getUnbluObject().floating.api.initialize();
            await unbluApi.deinitialize();
        }
    }
    static async deinitializeEmbeddedIfNeeded(excludedAppElement) {
        const unbluAppElements = document.getElementsByTagName('unblu-embedded-app');
        for (let i = 0; i < unbluAppElements.length; i++) {
            const appElement = unbluAppElements[i];
            if (appElement === excludedAppElement) {
                continue;
            }
            console.log("Deinitializing existing embedded integration:", appElement);
            await appElement.deinitialize();
        }
    }
    static sanitizeParameter(param) {
        if (!param || !param.trim()) {
            return null;
        }
        return param;
    }
}
//# sourceMappingURL=unblu-util.js.map