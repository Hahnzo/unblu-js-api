import { UnbluApiError, UnbluErrorType } from './unblu-api-error';
import { EventEmitter } from './internal/util/event-emitter';
/**
 * #### This class gives API access to the currently active conversation.
 *
 * As long as a conversation is active one can register and receive the events provided by this class and call the methods.
 * Once the conversation is closed this API object will be destroyed and no more event callbacks will be called.
 * Any subsequent calls will fail.
 *
 * Use the {@link CLOSE} event to de-init any code connected to this conversation.
 */
export class Conversation {
    /**
     * @hidden
     */
    constructor(conversationModule, conversationId) {
        this.conversationModule = conversationModule;
        this.conversationId = conversationId;
        this.eventEmitter = new EventEmitter();
        this.internalListeners = {};
        this.destroyed = false;
        // clean up all listeners when the conversation disconnects.
        this.on(Conversation.CLOSE, () => this.destroy());
    }
    /**
     * Adds a listener.
     * @param event The event to register.
     * @param listener The listener to register.
     */
    on(event, listener) {
        this.checkNotDestroyed();
        const needsInternalSubscription = !this.eventEmitter.hasListeners(event);
        this.eventEmitter.on(event, listener);
        if (needsInternalSubscription)
            this.onInternal(event);
    }
    /**
     * Removes a previously registered listener.
     * @param event The event to unregister from.
     * @param listener The listener to remove.
     */
    off(event, listener) {
        this.checkNotDestroyed();
        const removed = this.eventEmitter.off(event, listener);
        if (!this.eventEmitter.hasListeners(event))
            this.offInternal(event);
        return removed;
    }
    onInternal(eventName) {
        let internalListener;
        switch (eventName) {
            case Conversation.CONNECTION_STATE_CHANGE:
                internalListener = (event) => {
                    if (event.data.conversationId == this.conversationId)
                        this.eventEmitter.emit(event.name, event.data.connectionState);
                };
                break;
            case Conversation.CONVERSATION_STATE_CHANGE:
                internalListener = (event) => {
                    if (event.data.conversationId == this.conversationId)
                        this.eventEmitter.emit(event.name, event.data.conversationState);
                };
                break;
            case Conversation.CALL_STATE_CHANGE:
                internalListener = (event) => {
                    if (event.data.conversationId == this.conversationId)
                        this.eventEmitter.emit(event.name, event.data.callState);
                };
                break;
            case Conversation.CUSTOM_ACTION_INVOCATION:
                internalListener = (event) => {
                    if (event.data.conversation.id == this.conversationId)
                        this.eventEmitter.emit(event.name, event.data);
                };
                break;
            default:
                internalListener = (event) => {
                    if (event.data == this.conversationId) {
                        this.eventEmitter.emit(event.name);
                    }
                };
                break;
        }
        this.internalListeners[eventName] = internalListener;
        this.conversationModule.on(eventName, internalListener).catch(e => console.warn('Error registering internal listener for event:', eventName, 'error:' + e, e));
    }
    offInternal(eventName) {
        const listener = this.internalListeners[eventName];
        if (listener == null)
            return;
        delete this.internalListeners[eventName];
        this.conversationModule.off(eventName, listener).catch(e => console.warn('Error removing internal listener for event:', eventName, 'error:' + e, e));
    }
    /**
     * Returns the ID of this conversation.
     */
    getConversationId() {
        return this.conversationId;
    }
    /**
     * Returns the current connection state the conversation is in.
     *
     * If the connection is lost, the conversation will automatically try to reconnect using an exponential back-off strategy.
     * If a fatal error is detected, the state will change to {@link ConnectionState.ERROR}.
     *
     * If this happens, the conversation is in it's terminal state. A dialog or other UI will be displayed to the user with details on the failure.
     * The conversation is not automatically closed in this case.
     * It may either be closed through a manual action by the visitor (confirming the error) or via the API.
     *
     * @see {@link CONNECTION_STATE_CHANGE} if you need to listen to changes.
     * @return A promise that resolves to the current connection state of the conversation
     * or is rejected with a {@link UnbluApiError} if the call fails.
     */
    async getConnectionState() {
        this.checkNotDestroyed();
        return this.conversationModule.getConnectionState(this.conversationId);
    }
    /**
     * Returns the current state the conversation is in.
     * @return A promise that resolves to the current state of the conversation
     * or is rejected with a {@link UnbluApiError} if the call fails.
     */
    async getConversationState() {
        this.checkNotDestroyed();
        return this.conversationModule.getConversationState(this.conversationId);
    }
    /**
     * @see {@link CALL_STATE_CHANGE} if you need to listen to changes.
     * @return A promise that resolves to the current call state of the local user
     * or is rejected with a {@link UnbluApiError} if the call fails.
     */
    async getCallState() {
        this.checkNotDestroyed();
        return this.conversationModule.getCallState(this.conversationId);
    }
    /**
     * Set custom visitor data on the conversation.
     *
     * @param visitorData Custom data for the visitor in any format.
     */
    async setVisitorData(visitorData) {
        this.checkNotDestroyed();
        return this.conversationModule.setVisitorData(visitorData);
    }
    /**
     * Starts a voice call in this conversation.
     *
     * - If a call is already active, this call will be ignored.
     * - If the local person doesn't have the right to start a voice call,
     * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
     * @see {@link CALL_STATE_CHANGE} If you need to listen to changes.
     * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
     */
    async startAudioCall() {
        this.checkNotDestroyed();
        return this.conversationModule.startAudioCall(this.conversationId);
    }
    /**
     * Starts a video call in this conversation.
     *
     * - If a call is already active, this call will be ignored.
     * - If the local person doesn't have the right to start a video call,
     * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
     * @see {@link CALL_STATE_CHANGE} If you need to listen to changes.
     * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
     */
    async startVideoCall() {
        this.checkNotDestroyed();
        return this.conversationModule.startVideoCall(this.conversationId);
    }
    /**
     * Ends and closes this conversation.
     *
     * If the local person doesn't have the right to end the conversation,
     * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
     * @see {@link END} fired after this call.
     * @see {@link closeConversation} for details on closing a conversation.
     * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
     */
    async endConversation() {
        this.checkNotDestroyed();
        return this.conversationModule.endConversation(this.conversationId);
    }
    /**
     * Leaves and closes this conversation.
     *
     * By leaving, the visitor is removed from the active participant list of the conversation.
     * Once a conversation is left, the visitor can not re-open it. It will not be visible in the conversation history either.
     *
     * If the local person doesn't have the right to leave the conversation,
     * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
     * @see {@link CLOSE} fired after this call.
     * @see {@link closeConversation} for details on closing a conversation without leaving.
     * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
     */
    async leaveConversation() {
        this.checkNotDestroyed();
        return this.conversationModule.leaveConversation(this.conversationId);
    }
    /**
     * Closes this conversation locally.
     *
     * When called, the connection to this conversation is closed and the overview is displayed.
     *
     * **Note that:**
     * - Closing does NOT end the conversation.
     * - The person does NOT leave the conversation.
     * - All Conversation api instances for this conversation will be destroyed.
     *
     * The conversation can be joined again either via the UI or using {@link UnbluApi.openConversation}.
     * @see {@link CLOSE} fired after this call.
     * @see {@link endConversation} for details on ending a conversation.
     * @see {@link leaveConversation} for details on leaving a conversation.
     * @see {@link destroy} for details on destroying a conversation.
     * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
     */
    async closeConversation() {
        this.checkNotDestroyed();
        return this.conversationModule.closeConversation(this.conversationId);
    }
    checkNotDestroyed() {
        if (this.destroyed)
            throw new UnbluApiError(UnbluErrorType.ILLEGAL_STATE, 'Error: trying to execute method on destroyed conversation object.');
    }
    /**
     * Returns weather this conversation is destroyed or not.
     *
     * Conversations are destroyed if {@link destroy} is called or the conversation is closed.
     * This usually happens when the user navigates back to an overview or into an other conversation.
     * @see {@link destroy}
     * @see {@link CLOSE}
     * @return Weather this conversation is destroyed or not.
     */
    isDestroyed() {
        return this.destroyed;
    }
    /**
     * Destroys this conversation API instance.
     *
     * Calling destroy will unregister all event listeners and prohibit any further calls to this object.
     * Once the conversation is destroyed, any subsequent calls will reject the returned promise with {@link UnbluErrorType.ILLEGAL_STATE} as the reason.
     *
     * **Note that:**
     * - Destroying does NOT close the conversation .
     * - Destroying does NOT end the conversation.
     * - Destroying does NOT leave the conversation.
     * - Other instances of the same Conversation will NOT be destroyed.
     *
     * This call simply destroys this local API instance to the conversation.
     *
     * A destroyed but still open conversation can be accessed again using {@link UnbluApi.getActiveConversation}.
     *
     * @see {@link isDestroyed}
     * @see {@link closeConversation} for details on how to close a conversation
     * @see {@link endConversation} for details on how to end a conversation
     */
    destroy() {
        if (this.destroyed)
            return;
        this.destroyed = true;
        this.eventEmitter.reset();
        for (let event in this.internalListeners) {
            this.offInternal(event);
        }
    }
}
/**
 * Event emitted when the {@link ConnectionState} of this conversation changes.
 * @event connectionStateChange
 * @see {@link on} for listener registration
 */
Conversation.CONNECTION_STATE_CHANGE = 'connectionStateChange';
/**
 * Event emitted when the {@link ConversationState} of this conversation changes.
 * @event conversationStateChange
 * @see {@link on} for listener registration
 */
Conversation.CONVERSATION_STATE_CHANGE = 'conversationStateChange';
/**
 * Event emitted when the {@link CallState} of this conversation changes.
 * @event callStateChange
 * @see {@link on} for listener registration
 */
Conversation.CALL_STATE_CHANGE = 'callStateChange';
/**
 * Event emitted when the conversation ends.
 * @deprecated The end event is not always available, depending on the configuration. Use the {@link CONVERSATION_STATE_CHANGE} event instead.
 * @event end
 * @see {@link on} for listener registration
 */
Conversation.END = 'end';
/**
 * Event emitted when the conversation is closed.
 *
 * This may happen due to a UI-navigation or an API-call.
 *
 * @event close
 * @see {@link on} for listener registration
 */
Conversation.CLOSE = 'close';
/**
 * Event emitted every time a custom action is configured to trigger a JS API event for the current client when a custom action is invoked
 *
 * @event customActionInvocation
 * @see {@link CustomActionInvocationListener}
 * @see {@link on} for listener registration
 */
Conversation.CUSTOM_ACTION_INVOCATION = 'customActionInvocation';
//# sourceMappingURL=conversation.js.map