import { EventEmitter } from './shared/internal/util/event-emitter';
import { UnbluApiError, UnbluErrorType } from './shared/unblu-api-error';
/**
 * This class allows you to control the UI state and the Unblu individual UI.
 */
export class UnbluUiApi {
    /**
     * @hidden
     */
    constructor(internalApi) {
        this.internalApi = internalApi;
        this.internalListeners = {};
        this.eventEmitter = new EventEmitter();
        internalApi.meta.on('upgraded', () => this.onUpgraded());
    }
    on(event, listener) {
        const needsInternalSubscription = !this.eventEmitter.hasListeners(event);
        this.eventEmitter.on(event, listener);
        if (needsInternalSubscription)
            this.onInternal(event).catch(e => console.warn('Error registering internal listener for event:', event, 'error:' + e, e));
    }
    /**
     * Removes a previously registered listener
     * @param event The event to unregister from.
     * @param listener The listener to remove.
     */
    off(event, listener) {
        const removed = this.eventEmitter.off(event, listener);
        if (!this.eventEmitter.hasListeners(event))
            this.offInternal(event).catch(e => console.warn('Error removing internal listener for event:', event, 'error:' + e, e));
        return removed;
    }
    async onInternal(eventName) {
        let internalListener;
        switch (eventName) {
            case UnbluUiApi.UI_STATE_CHANGE:
                internalListener = (event) => {
                    this.eventEmitter.emit(event.name, event.data);
                };
                break;
            case UnbluUiApi.UI_ACTIVE_INDIVIDUAL_UI_VIEW_CHANGE:
                internalListener = (event) => {
                    this.eventEmitter.emit(event.name, event.data);
                };
                break;
            default:
                throw new UnbluApiError(UnbluErrorType.INVALID_FUNCTION_ARGUMENTS, 'Registration to unknown event:' + eventName);
        }
        if (await this.internalApi.meta.isUpgraded()) {
            this.internalListeners[eventName] = internalListener;
            try {
                await this.internalApi.general.on(eventName, internalListener);
            }
            catch (e) {
                delete this.internalListeners[eventName];
                throw e;
            }
        }
    }
    async offInternal(eventName) {
        const listener = this.internalListeners[eventName];
        if (listener == null) {
            return;
        }
        delete this.internalListeners[eventName];
        await this.internalApi.general.off(eventName, listener);
    }
    /**
     * Opens the individual UI if it is collapsed and collapses it if it is open.
     */
    async toggleIndividualUi() {
        await this.requireUpgrade();
        await this.internalApi.general.toggleIndividualUi();
    }
    /**
     * Navigates the individual UI to the PIN entry UI.
     *
     * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use {@link openIndividualUi} if this is needed.
     */
    async openPinEntryUi() {
        await this.requireUpgrade();
        await this.internalApi.general.openPinEntryUi();
    }
    /**
     * Navigates the individual UI to the overview UI.
     *
     * <p>
     *     Be aware that this method will force to close any currently open conversation. Depending on the conversation's configuration and the activity in it a prompt may be displayed that has to be accepted by the visitor before the navigation to the overview can happen.
     * </p>
     *
     * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use {@link openIndividualUi} if this is needed.
     */
    async openOverviewUi() {
        await this.requireUpgrade();
        await this.internalApi.general.openOverviewUi();
    }
    /**
     * Pop-out the individual UI into a separate window.
     *
     * **NOTE:** this has to be called in a click-event in order to be able to open the pop-up window without being blocked by the browser!
     */
    async popoutIndividualUi() {
        await this.requireUpgrade();
        await this.internalApi.general.popoutIndividualUi();
    }
    /**
     * Pop-in the individual UI when it is in [POPPED_OUT]{@link IndividualUiState.POPPED_OUT} state.
     *
     * The pop-out window will automatically close and the individual UI will be displayed in the original window again.
     */
    async popinIndividualUi() {
        await this.requireUpgrade();
        await this.internalApi.general.popinIndividualUi();
    }
    /**
     * Maximize the individual UI - Does nothing if it is already maximized or popped out.
     */
    async maximizeIndividualUi() {
        await this.requireUpgrade();
        await this.internalApi.general.maximizeIndividualUi();
    }
    /**
     * Minimize the individual UI - Does nothing if it is already minimized.
     */
    async minimizeIndividualUi() {
        await this.requireUpgrade();
        await this.internalApi.general.minimizeIndividualUi();
    }
    /**
     * Opens the individual UI if it was collapsed. - Does nothing if it was already open.
     */
    async openIndividualUi() {
        await this.requireUpgrade();
        await this.internalApi.general.openIndividualUi();
    }
    /**
     * Collapses the individual UI if it was open. - Does nothing if it was already collapsed.
     */
    async collapseIndividualUi() {
        await this.requireUpgrade();
        await this.internalApi.general.collapseIndividualUi();
    }
    /**
     * Get the state of the individual UI.
     * @return A promise that resolves to the {@link IndividualUiState} of the individual UI.
     */
    async getIndividualUiState() {
        if (!await this.internalApi.meta.isUpgraded()) {
            return "COLLAPSED" /* IndividualUiState.COLLAPSED */;
        }
        return await this.internalApi.general.getIndividualUiState();
    }
    /**
     * Get the active individual UI view.
     *
     * NOTE: The view being active doesn't necessarily mean it's visible to the user. The UI as a whole may be
     * collapsed, for instance.
     *
     * @return A promise that resolves to the {@link ActiveIndividualUiView} of the individual UI.
     * @see {@link getIndividualUiState}
     */
    async getActiveIndividualUiView() {
        if (!await this.internalApi.meta.isUpgraded()) {
            return "UNKNOWN" /* ActiveIndividualUiView.UNKNOWN */;
        }
        return await this.internalApi.general.getActiveIndividualUiView();
    }
    async requireUpgrade() {
        await this.internalApi.meta.upgrade(false);
    }
    onUpgraded() {
        for (let event of this.eventEmitter.getEventsWithListeners()) {
            // register internal listeners for all events that need upgrade.
            if (!this.internalListeners[event])
                this.onInternal(event);
        }
    }
}
/**
 * Event emitted every time the state of the individual UI is changed.
 *
 * @event uiStateChange
 * @see {@link on} for listener registration
 * @see {@link UiStateChangeListener}
 */
UnbluUiApi.UI_STATE_CHANGE = 'uiStateChange';
/**
 * Event emitted every time individual UI view changes.
 *
 * NOTE: This event is also triggered when an individual UI view change happens, but the UI isn't
 * visible, for example, because it's collapsed.
 *
 * @event uiActiveIndividualUiViewChange
 * @see {@link on} for listener registration
 * @see {@link UiActiveIndividualUiViewChangeListener}
 */
UnbluUiApi.UI_ACTIVE_INDIVIDUAL_UI_VIEW_CHANGE = 'uiActiveIndividualUiViewChange';
//# sourceMappingURL=unblu-api-ui.js.map