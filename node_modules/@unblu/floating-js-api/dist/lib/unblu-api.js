import { Conversation } from './shared/conversation';
import { EventEmitter } from './shared/internal/util/event-emitter';
import { UnbluApiError, UnbluErrorType } from './shared/unblu-api-error';
import { UnbluUiApi } from './unblu-api-ui';
import { UnbluUtil } from "./shared/internal/unblu-util";
/**
 * #### This class represents the initialized Unblu Floating JS API.
 *
 * There is only ever one instance of this api which can be retrieved via `unblu.floating.api.initialize()`.
 * See {@link UnbluStaticApi} for more details on configuring and initializing the UnbluApi.
 *
 * The API connects to the integrated version of Unblu. All actions performed via the UnbluApi are executed in
 * the name of and with the rights of current visitor and may have direct effect on the displayed Unblu UI.
 *
 * For example if a conversation is started from the UnbluApi, the Unblu UI will navigate to it.
 * If a conversation is closed via the API, it will also be closed on the Unblu UI of the visitor.
 * For more information on UI side effects please check the documentation for each method call.
 *
 * For programmatic administrator access and configuration of Unblu please use the Unblu WebAPI.
 */
export class UnbluApi {
    /**
     * @hidden
     */
    constructor(internalApi) {
        this.internalApi = internalApi;
        this.internalListeners = {};
        this.eventEmitter = new EventEmitter();
        internalApi.meta.on('upgraded', () => this.onUpgraded());
        // All UI functionality is provided with the ui namespace
        this.ui = new UnbluUiApi(internalApi);
    }
    on(event, listener) {
        this.assertNotDeinitialized();
        const needsInternalSubscription = !this.eventEmitter.hasListeners(event);
        this.eventEmitter.on(event, listener);
        if (needsInternalSubscription)
            this.onInternal(event).catch(e => console.warn('Error registering internal listener for event:', event, 'error:' + e, e));
    }
    /**
     * Removes a previously registered listener
     * @param event The event to unregister from.
     * @param listener The listener to remove.
     */
    off(event, listener) {
        this.assertNotDeinitialized();
        const removed = this.eventEmitter.off(event, listener);
        if (!this.eventEmitter.hasListeners(event))
            this.offInternal(event).catch(e => console.warn('Error removing internal listener for event:', event, 'error:' + e, e));
        return removed;
    }
    async onInternal(eventName) {
        let internalListener;
        let internalModule;
        let needsUpgrade;
        switch (eventName) {
            case UnbluApi.AGENT_AVAILABLE_CHANGE:
                internalListener = (event) => {
                    this.eventEmitter.emit(event.name, event.data);
                };
                internalModule = this.internalApi.agentAvailability;
                needsUpgrade = false;
                break;
            case UnbluApi.AGENT_AVAILABILITY_CHANGE:
                internalListener = (event) => {
                    this.eventEmitter.emit(event.name, event.data);
                };
                internalModule = this.internalApi.agentAvailability;
                needsUpgrade = false;
                break;
            case UnbluApi.ACTIVE_CONVERSATION_CHANGE:
                internalListener = (event) => {
                    this.eventEmitter.emit(event.name, event.data ? new Conversation(this.internalApi.conversation, event.data) : null);
                };
                internalModule = this.internalApi.general;
                needsUpgrade = true;
                break;
            case UnbluApi.CONVERSATIONS_CHANGE:
                internalListener = (event) => {
                    this.eventEmitter.emit(event.name, event.data);
                };
                internalModule = this.internalApi.general;
                needsUpgrade = true;
                break;
            case UnbluApi.NOTIFICATION_COUNT_CHANGE:
            case UnbluApi.PERSON_CHANGE:
            case UnbluApi.PERSON_ACTIVITY:
                internalListener = (event) => {
                    this.eventEmitter.emit(event.name, event.data);
                };
                internalModule = this.internalApi.general;
                needsUpgrade = true;
                break;
            case UnbluApi.DEINITIALIZING:
            case UnbluApi.DEINITIALIZED:
                internalListener = (event) => {
                    this.eventEmitter.emit(event.name, event.data);
                };
                internalModule = this.internalApi.meta;
                needsUpgrade = false;
                break;
            default:
                throw new UnbluApiError(UnbluErrorType.INVALID_FUNCTION_ARGUMENTS, 'Registration to unknown event:' + eventName);
        }
        if (!needsUpgrade || await this.internalApi.meta.isUpgraded()) {
            this.internalListeners[eventName] = internalListener;
            try {
                await internalModule.on(eventName, internalListener);
            }
            catch (e) {
                delete this.internalListeners[eventName];
                throw e;
            }
        }
    }
    async offInternal(eventName) {
        const listener = this.internalListeners[eventName];
        if (listener == null) {
            return;
        }
        delete this.internalListeners[eventName];
        let internalModule;
        switch (eventName) {
            case UnbluApi.AGENT_AVAILABILITY_CHANGE:
                internalModule = this.internalApi.agentAvailability;
                break;
            case UnbluApi.DEINITIALIZING:
            case UnbluApi.DEINITIALIZED:
                internalModule = this.internalApi.meta;
                break;
            default:
                internalModule = this.internalApi.general;
                break;
        }
        await internalModule.off(eventName, listener);
    }
    // General
    /**
     * Returns information about the visitor.
     * @return A promise that resolves to the current visitors person info.
     */
    async getPersonInfo() {
        this.assertNotDeinitialized();
        await this.requireUpgrade();
        return this.internalApi.general.getPersonInfo();
    }
    /**
     * Sets the current visitor's nickname.
     * This could be set before or during a conversation.
     * @return A promise that resolves empty when the operation is done
     */
    async setPersonNickname(nickname) {
        this.assertNotDeinitialized();
        await this.requireUpgrade();
        return this.internalApi.general.setPersonNickname(nickname);
    }
    /**
     * Adds the label with the given labelName to the current visitor.
     * This only adds the label as long as it exists, can be set on visitors and the visitor is allowed to set the label.
     * @returns A promise that resolves empty when the operation is done or is rejected if it failed.
     */
    async addPersonLabel(labelName) {
        this.assertNotDeinitialized();
        await this.requireUpgrade();
        return this.internalApi.general.addPersonLabel(labelName);
    }
    /**
     * Removes the label with the given labelName from the current visitor.
     * This only removes the label as long as the visitor has the label applied to themselves and the visitor is allowed to remove the label.
     * @returns A promise that resolves empty when the operation is done or is rejected if it failed.
     */
    async removePersonLabel(labelName) {
        this.assertNotDeinitialized();
        await this.requireUpgrade();
        return this.internalApi.general.removePersonLabel(labelName);
    }
    /**
     * Logs the current visitor in using the `authenticator/loginWithSecureToken` web API endpoint.
     * Depending on the configuration, existing conversation may will be transferred to the authenticated user.
     * @param accessToken The access token (JWT) to authenticate the visitor with
     * @return A promise that resolves empty if the login succeeds or is rejected if it fails
     */
    async login(accessToken) {
        this.assertNotDeinitialized();
        return UnbluUtil.loginWithSecureToken(this.internalApi.configuration.serverUrl || '', this.internalApi.configuration.apiKey, this.internalApi.configuration.entryPath || '/unblu', accessToken);
    }
    /**
     * Checks if the current visitor is authenticated.
     * @return A promise that resolves to a boolean if the visitor is authenticated
     */
    async isAuthenticated() {
        this.assertNotDeinitialized();
        return UnbluUtil.isAuthenticated(this.internalApi.configuration.serverUrl || '', this.internalApi.configuration.entryPath || '/unblu');
    }
    /**
     * Logs the visitor out.
     * The user will not have access to conversations from the authenticated visitor he was before anymore. He needs to be authenticated again for that.
     * @return A promise that resolves empty when the logout succeeds or is rejected if it fails
     */
    async logout() {
        this.assertNotDeinitialized();
        return UnbluUtil.logout(this.internalApi.configuration.serverUrl || '', this.internalApi.configuration.entryPath || '/unblu');
    }
    /**
     * Returns the number of unread messages.
     * @return A promise that resolves to the current number of unread messages.
     */
    async getNotificationCount() {
        this.assertNotDeinitialized();
        if (await this.internalApi.meta.isUpgraded()) {
            return this.internalApi.general.getNotificationCount();
        }
        else {
            return this.internalApi.generalLazy.getNotificationCount();
        }
    }
    // Conversation
    /**
     * Starts a new Conversation and places it into the inbound conversation queue.
     *
     * Starting a new conversation involves an agent availability check.
     * For {@link ConversationType.OFFLINE_CHAT_REQUEST} conversations, the check proceeds as follows:
     * * If an agent is available, the conversation type will be changed to {@link ConversationType.CHAT_REQUEST}.
     * * If no agents are available, it will start an offline conversation provided offline chat requests are enabled in the Unblu server's configuration.
     * * if offline chat requests aren't enabled, the request will be rejected.
     *
     * For all `online` conversation types, the check works as follows:
     * * If an agent is available, the conversation will be started.
     * * If no agents are available, the request will be rejected.
     *
     * You should therefore always check agent availability before starting a new conversation.
     * If no agents are available, only start conversations of the type {@link ConversationType.OFFLINE_CHAT_REQUEST}.
     *
     * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use [ui.openIndividualUi()]{@link UnbluUiApi.openIndividualUi} if this is needed.
     *
     * @param type The conversation type that shall be started.
     * @param visitorName The name the local visitor should have. This is only taken into account if the visitor is not already authenticated.
     * @param visitorData Custom data for the visitor in any format. **NOTE:** The data which is passed here could be used in [NewConversationCallback]{@link NewConversationInterceptor}
     * @param recipient The team or agent recipient of the conversation. This will overwrite any named area that might be set for this web page. **NOTE:** The data which is passed here could be used in [NewConversationCallback]{@link NewConversationInterceptor}
     * @return A promise that resolves to the conversation object giving API access to the started conversation.
     */
    async startConversation(type, visitorName, visitorData, recipient) {
        this.assertNotDeinitialized();
        await this.requireUpgrade();
        const conversationId = await this.internalApi.general.startConversation(type, visitorName, visitorData, recipient);
        return new Conversation(this.internalApi.conversation, conversationId);
    }
    /**
     * Set a custom interceptor which will be triggered when a new conversation is started (initiated from UI or JavaScript).
     * @param callback The interceptor which is called before a new conversation is started. The Callback is of type [NewConversationCallback]{@link NewConversationInterceptor}
     * @return A promise that resolves when the interceptor is successfully applied and active.
     */
    async setNewConversationInterceptor(callback) {
        this.assertNotDeinitialized();
        if (!await this.internalApi.meta.isUpgraded()) {
            return await this.internalApi.generalLazy.setNewConversationInterceptor(callback);
        }
        else {
            return await this.internalApi.general.setNewConversationInterceptor(callback);
        }
    }
    /**
     * Joins an existing conversation with a given PIN.
     *
     * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use [ui.openIndividualUi()]{@link UnbluUiApi.openIndividualUi} if this is needed.
     *
     * @param pin The PIN retrieved from the Unblu Agent Desk.
     * @param visitorName The name the local visitor should have. This is only taken into account if the visitor is not already authenticated.
     * @return A promise that resolves to the conversation object giving API access to the joined conversation.
     */
    async joinConversation(pin, visitorName) {
        this.assertNotDeinitialized();
        await this.requireUpgrade();
        const conversationId = await this.internalApi.general.joinConversation(pin, visitorName);
        return new Conversation(this.internalApi.conversation, conversationId);
    }
    /**
     * Opens the existing conversation with the given conversation ID.
     *
     * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use [ui.openIndividualUi()]{@link UnbluUiApi.openIndividualUi} if this is needed.
     *
     * @param conversationId The id of the conversation to be opened.
     * @return A promise that resolves to the conversation object giving API access to the opened conversation.
     */
    async openConversation(conversationId) {
        this.assertNotDeinitialized();
        await this.requireUpgrade();
        await this.internalApi.general.openConversation(conversationId);
        return new Conversation(this.internalApi.conversation, conversationId);
    }
    /**
     * Returns the currently active conversation or `null` if no conversation is active.
     *
     * **NOTE:** calling this method twice while the same conversation is active, will result in two individual conversation API instances being returned.
     * destroying one of them will not cause the other one to also be destroyed. If however the active conversation is closed, all returned Conversation instances will be destroyed.
     *
     * @return A promise that either resolves to the currently active conversation or `null` if no conversation is open.
     * @see {@link ACTIVE_CONVERSATION_CHANGE}
     */
    async getActiveConversation() {
        this.assertNotDeinitialized();
        if (await this.internalApi.meta.isUpgraded()) {
            const conversationId = await this.internalApi.general.getActiveConversation();
            return conversationId != null ? new Conversation(this.internalApi.conversation, conversationId) : null;
        }
        else {
            return null;
        }
    }
    /**
     * Returns all conversations of the current visitor. If no conversation is present, an empty array is returned.
     *
     * @return A promise that resolves to an array of [ConversationInfo]{@link ConversationInfo}.
     */
    async getConversations() {
        this.assertNotDeinitialized();
        await this.requireUpgrade();
        return await this.internalApi.general.getConversations();
    }
    /**
     * Checks if an agent is available for the current named area and language.
     *
     * @return Promise that resolves to `true` if the availability state is [AVAILABLE]{@link AgentAvailabilityState.AVAILABLE} or [BUSY]{@link AgentAvailabilityState.BUSY}, `false` otherwise.
     * @see {@link getAgentAvailabilityState} for a more detailed check.
     */
    async isAgentAvailable() {
        this.assertNotDeinitialized();
        return this.internalApi.agentAvailability.isAgentAvailable();
    }
    /**
     * Returns the current availability state for the current named area and language.
     * @return Promise that resolves to the current availability state.
     * @see {@link isAgentAvailable} for a simpler check.
     */
    async getAgentAvailabilityState() {
        this.assertNotDeinitialized();
        return this.internalApi.agentAvailability.getAgentAvailabilityState();
    }
    async requireUpgrade() {
        await this.internalApi.meta.upgrade(false);
    }
    onUpgraded() {
        for (let event of this.eventEmitter.getEventsWithListeners()) {
            // register internal listeners for all events that need upgrade.
            if (!this.internalListeners[event])
                this.onInternal(event);
        }
    }
    assertNotDeinitialized() {
        if (this.isDeinitialized()) {
            throw new UnbluApiError(UnbluErrorType.ILLEGAL_STATE, 'Error: trying to execute method on deinitialized UnbluApi instance.');
        }
    }
    isDeinitialized() {
        return this.internalApi == null;
    }
    /**
     * De-initializes the API. It will destroy the UI, all connections and will release all resources (as far as it is technically possible).
     *
     * Afterwards the API can be initialized again via  {@link UnbluStaticApi.initialize | window.unblu.floating.api.initialize()}
     */
    async deinitialize() {
        if (this.isDeinitialized()) {
            return;
        }
        await this.internalApi.meta.deinitialize();
        this.internalApi = null;
        this.ui = null;
        this.internalListeners = null;
        this.eventEmitter = null;
    }
}
/**
 * Event emitted every time the active conversation changes.
 *
 * This may happen due to a UI-navigation or an API-call.
 *
 * @event activeConversationChange
 * @see {@link on} for listener registration
 * @see {@link ConversationChangeListener}
 */
UnbluApi.ACTIVE_CONVERSATION_CHANGE = 'activeConversationChange';
/**
 * Event emitted every time one of the conversations accessible to the current user changes or one is added or removed.
 *
 * @event conversationsChanged
 * @see {@link on} for listener registration
 * @see {@link ConversationsChangeListener}
 */
UnbluApi.CONVERSATIONS_CHANGE = 'conversationsChange';
/**
 * Event emitted every time the notification count (unread messages) changes.
 *
 * @event notificationCountChange
 * @see {@link on} for listener registration
 * @see {@link NotificationCountChangeListener}
 */
UnbluApi.NOTIFICATION_COUNT_CHANGE = 'notificationCountChange';
/**
 * Event emitted every time the local person changes. This may be i.e. due to the person setting its name.
 *
 * @event personChange
 * @see {@link on} for listener registration
 * @see {@link PersonChangeListener}
 */
UnbluApi.PERSON_CHANGE = 'personChange';
/**
 * Event emitted every time the local person has some activity inside Unblu.
 * This may be i.e. an interaction with the chat, a call, opening a conversation or interacting
 * with a co-browsing layer.
 *
 * The event can be used to reset the logout timer inside an authenticated area, for example.
 *
 * The configuration property com.unblu.conversation.activity.activityCategoriesToTrack specifies which categories of activity trigger the event.
 *
 * @event personActivity
 * @see {@link on} for listener registration
 * @see {@link PersonActivityListener}
 */
UnbluApi.PERSON_ACTIVITY = 'personActivity';
/**
 * Event emitted every time the agent availability changes for the current named area and locale.
 *
 * @event availableChange
 * @see {@link on} for listener registration
 * @see {@link AgentAvailableChangeListener}
 */
UnbluApi.AGENT_AVAILABLE_CHANGE = 'availableChange';
/**
 * Event emitted every time the agent availability state changes for the current named area and locale.
 *
 * @event availabilityChange
 * @see {@link on} for listener registration
 * @see {@link AgentAvailabilityChangeListener}
 */
UnbluApi.AGENT_AVAILABILITY_CHANGE = 'availabilityChange';
/**
 * Event emitted when this instance gets de-initialized and is not usable at the time until it fully got de-initialized.
 *
 * @event deinitializing
 * @see {@link on} for listener registration
 * @see {@link DeinitializationListener}
 */
UnbluApi.DEINITIALIZING = 'deinitializing';
/**
 * Event emitted when this instance got de-initialized and has to be initialized again.
 *
 * @event deinitialized
 * @see {@link on} for listener registration
 * @see {@link DeinitializationListener}
 */
UnbluApi.DEINITIALIZED = 'deinitialized';
//# sourceMappingURL=unblu-api.js.map