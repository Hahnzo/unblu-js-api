import { InternalApi } from './internal/internal-api';
import { Conversation } from './shared/conversation';
import { PersonInfo } from './shared/model/person-info';
import { Listener } from './shared/internal/util/event-emitter';
import { ConversationType } from './shared/model/conversation-type';
import { AgentAvailabilityState } from './shared/model/agent-availability-state';
import { AgentAvailabilityEventType } from './shared/internal/module/agent-availability-module';
import { UnbluUiApi } from './unblu-api-ui';
import { MetaEventType } from "./internal/module/meta-module";
import { ConversationInfo } from "./shared/model/conversation-info";
import { NewConversationInterceptor } from "./shared/new-conversation-interceptor";
import { GeneralEventType } from "./internal/module/general-module";
import { InitializedUnbluApi } from "./shared/internal/initialized-unblu-api";
import { NewConversationRecipient } from "./shared/model/new-conversation-recipient";
/**
 * Listener called whenever the active conversation changes.
 *
 * **Note:** If no conversation is currently active the passed conversation object will be `null`
 * @param conversation API object for the active conversation or `null` if no conversation is active.
 */
export type ConversationChangeListener = (conversation?: Conversation) => void;
/**
 * Listener called whenever a conversation changed, added or removed from all conversations.
 * @param conversations All conversations of the current visitor.
 */
export type ConversationsChangeListener = (conversations: ConversationInfo[]) => void;
/**
 * Listener called whenever the notification count of a person (i.e. unread messages) changes.
 * @param count The number of unseen notifications.
 */
export type NotificationCountChangeListener = (count: number) => void;
/**
 * Listener called whenever the local person changes.
 * @param person Info about the person.
 */
export type PersonChangeListener = (person: PersonInfo) => void;
/**
 * Listener called whenever there is activity by the person.
 * @param lastActivity A UTC timestamp when the last activity happened.
 */
export type PersonActivityListener = (lastActivity: Number) => void;
/**
 * Listener called whenever the agent availability changes.
 * @param isAvailable A boolean that indicates if an agent is available.
 */
export type AgentAvailableChangeListener = (isAvailable: boolean) => void;
/**
 * Listener called whenever the agent availability state changes.
 * @param availability The new availability state.
 */
export type AgentAvailabilityChangeListener = (availability: AgentAvailabilityState) => void;
/**
 * Listener called whenever the UnbluApi gets de-initialized.
 */
export type DeinitializationListener = () => void;
/**
 * #### This class represents the initialized Unblu Floating JS API.
 *
 * There is only ever one instance of this api which can be retrieved via `unblu.floating.api.initialize()`.
 * See {@link UnbluStaticApi} for more details on configuring and initializing the UnbluApi.
 *
 * The API connects to the integrated version of Unblu. All actions performed via the UnbluApi are executed in
 * the name of and with the rights of current visitor and may have direct effect on the displayed Unblu UI.
 *
 * For example if a conversation is started from the UnbluApi, the Unblu UI will navigate to it.
 * If a conversation is closed via the API, it will also be closed on the Unblu UI of the visitor.
 * For more information on UI side effects please check the documentation for each method call.
 *
 * For programmatic administrator access and configuration of Unblu please use the Unblu WebAPI.
 */
export declare class UnbluApi implements InitializedUnbluApi {
    private internalApi;
    /**
     * Event emitted every time the active conversation changes.
     *
     * This may happen due to a UI-navigation or an API-call.
     *
     * @event activeConversationChange
     * @see {@link on} for listener registration
     * @see {@link ConversationChangeListener}
     */
    static readonly ACTIVE_CONVERSATION_CHANGE: 'activeConversationChange';
    /**
     * Event emitted every time one of the conversations accessible to the current user changes or one is added or removed.
     *
     * @event conversationsChanged
     * @see {@link on} for listener registration
     * @see {@link ConversationsChangeListener}
     */
    static readonly CONVERSATIONS_CHANGE: 'conversationsChange';
    /**
     * Event emitted every time the notification count (unread messages) changes.
     *
     * @event notificationCountChange
     * @see {@link on} for listener registration
     * @see {@link NotificationCountChangeListener}
     */
    static readonly NOTIFICATION_COUNT_CHANGE: 'notificationCountChange';
    /**
     * Event emitted every time the local person changes. This may be i.e. due to the person setting its name.
     *
     * @event personChange
     * @see {@link on} for listener registration
     * @see {@link PersonChangeListener}
     */
    static readonly PERSON_CHANGE: 'personChange';
    /**
     * Event emitted every time the local person has some activity inside Unblu.
     * This may be i.e. an interaction with the chat, a call, opening a conversation or interacting
     * with a co-browsing layer.
     *
     * The event can be used to reset the logout timer inside an authenticated area, for example.
     *
     * The configuration property com.unblu.conversation.activity.activityCategoriesToTrack specifies which categories of activity trigger the event.
     *
     * @event personActivity
     * @see {@link on} for listener registration
     * @see {@link PersonActivityListener}
     */
    static readonly PERSON_ACTIVITY: 'personActivity';
    /**
     * Event emitted every time the agent availability changes for the current named area and locale.
     *
     * @event availableChange
     * @see {@link on} for listener registration
     * @see {@link AgentAvailableChangeListener}
     */
    static readonly AGENT_AVAILABLE_CHANGE: 'availableChange';
    /**
     * Event emitted every time the agent availability state changes for the current named area and locale.
     *
     * @event availabilityChange
     * @see {@link on} for listener registration
     * @see {@link AgentAvailabilityChangeListener}
     */
    static readonly AGENT_AVAILABILITY_CHANGE: 'availabilityChange';
    /**
     * Event emitted when this instance gets de-initialized and is not usable at the time until it fully got de-initialized.
     *
     * @event deinitializing
     * @see {@link on} for listener registration
     * @see {@link DeinitializationListener}
     */
    static readonly DEINITIALIZING: 'deinitializing';
    /**
     * Event emitted when this instance got de-initialized and has to be initialized again.
     *
     * @event deinitialized
     * @see {@link on} for listener registration
     * @see {@link DeinitializationListener}
     */
    static readonly DEINITIALIZED: 'deinitialized';
    /**
     * Access the UI functionality over the UI property.
     */
    ui: UnbluUiApi;
    private internalListeners;
    private eventEmitter;
    /**
     * @hidden
     */
    constructor(internalApi: InternalApi);
    /**
     * Registers an event listener for the given event.
     * @param event The activeConversationChange event.
     * @param listener The listener to be called.
     * @see {@link ACTIVE_CONVERSATION_CHANGE}
     */
    on(event: typeof UnbluApi.ACTIVE_CONVERSATION_CHANGE, listener: ConversationChangeListener): void;
    /**
     * Registers an event listener for the given event.
     * @param event The notificationCountChange event.
     * @param listener The listener to be called.
     * @see {@link NOTIFICATION_COUNT_CHANGE}
     */
    /**
     * Registers an event listener for the given event.
     * @param event The conversationsChanged event.
     * @param listener The listener to be called.
     * @see {@link CONVERSATIONS_CHANGE}
     */
    on(event: typeof UnbluApi.CONVERSATIONS_CHANGE, listener: ConversationsChangeListener): void;
    /**
     * Registers an event listener for the given event.
     * @param event The notificationCountChanged event.
     * @param listener The listener to be called.
     * @see {@link NOTIFICATION_COUNT_CHANGE}
     */
    on(event: typeof UnbluApi.NOTIFICATION_COUNT_CHANGE, listener: NotificationCountChangeListener): void;
    /**
     * Registers an event listener for the given event.
     * @param event The personChange event.
     * @param listener The listener to be called.
     * @see {@link PERSON_CHANGE}
     */
    on(event: typeof UnbluApi.PERSON_CHANGE, listener: PersonChangeListener): void;
    /**
     * Registers an event listener for the given event.
     * @param event The personActivity event.
     * @param listener The listener to be called.
     * @see {@link PERSON_ACTIVITY}
     */
    on(event: typeof UnbluApi.PERSON_ACTIVITY, listener: PersonActivityListener): void;
    /**
     * Registers an event listener for the given event.
     * @param event The agentAvailableChange event.
     * @param listener The listener to be called.
     * @see {@link AGENT_AVAILABLE_CHANGE}
     */
    on(event: typeof UnbluApi.AGENT_AVAILABLE_CHANGE, listener: AgentAvailableChangeListener): void;
    /**
     * Registers an event listener for the given event.
     * @param event The agentAvailabilityChange event.
     * @param listener The listener to be called.
     * @see {@link AGENT_AVAILABILITY_CHANGE}
     */
    on(event: typeof UnbluApi.AGENT_AVAILABILITY_CHANGE, listener: AgentAvailabilityChangeListener): void;
    /**
     * Registers an event listener for the given event.
     * @param event The deinitializing event.
     * @param listener The listener to be called.
     * @see {@link DEINITIALIZING}
     */
    on(event: typeof UnbluApi.DEINITIALIZING, listener: DeinitializationListener): void;
    /**
     * Registers an event listener for the given event.
     * @param event The deinitialized event.
     * @param listener The listener to be called.
     * @see {@link DEINITIALIZED}
     */
    on(event: typeof UnbluApi.DEINITIALIZED, listener: DeinitializationListener): void;
    /**
     * Removes a previously registered listener
     * @param event The event to unregister from.
     * @param listener The listener to remove.
     */
    off(event: GeneralEventType | AgentAvailabilityEventType | MetaEventType, listener: Listener): boolean;
    private onInternal;
    private offInternal;
    /**
     * Returns information about the visitor.
     * @return A promise that resolves to the current visitors person info.
     */
    getPersonInfo(): Promise<PersonInfo>;
    /**
     * Sets the current visitor's nickname.
     * This could be set before or during a conversation.
     * @return A promise that resolves empty when the operation is done
     */
    setPersonNickname(nickname: string): Promise<void>;
    /**
     * Adds the label with the given labelName to the current visitor.
     * This only adds the label as long as it exists, can be set on visitors and the visitor is allowed to set the label.
     * @returns A promise that resolves empty when the operation is done or is rejected if it failed.
     */
    addPersonLabel(labelName: string): Promise<void>;
    /**
     * Removes the label with the given labelName from the current visitor.
     * This only removes the label as long as the visitor has the label applied to themselves and the visitor is allowed to remove the label.
     * @returns A promise that resolves empty when the operation is done or is rejected if it failed.
     */
    removePersonLabel(labelName: string): Promise<void>;
    /**
     * Logs the current visitor in using the `authenticator/loginWithSecureToken` web API endpoint.
     * Depending on the configuration, existing conversation may will be transferred to the authenticated user.
     * @param accessToken The access token (JWT) to authenticate the visitor with
     * @return A promise that resolves empty if the login succeeds or is rejected if it fails
     */
    login(accessToken: string): Promise<void>;
    /**
     * Checks if the current visitor is authenticated.
     * @return A promise that resolves to a boolean if the visitor is authenticated
     */
    isAuthenticated(): Promise<boolean>;
    /**
     * Logs the visitor out.
     * The user will not have access to conversations from the authenticated visitor he was before anymore. He needs to be authenticated again for that.
     * @return A promise that resolves empty when the logout succeeds or is rejected if it fails
     */
    logout(): Promise<void>;
    /**
     * Returns the number of unread messages.
     * @return A promise that resolves to the current number of unread messages.
     */
    getNotificationCount(): Promise<number>;
    /**
     * Starts a new Conversation and places it into the inbound conversation queue.
     *
     * Starting a new conversation involves an agent availability check.
     * For {@link ConversationType.OFFLINE_CHAT_REQUEST} conversations, the check proceeds as follows:
     * * If an agent is available, the conversation type will be changed to {@link ConversationType.CHAT_REQUEST}.
     * * If no agents are available, it will start an offline conversation provided offline chat requests are enabled in the Unblu server's configuration.
     * * if offline chat requests aren't enabled, the request will be rejected.
     *
     * For all `online` conversation types, the check works as follows:
     * * If an agent is available, the conversation will be started.
     * * If no agents are available, the request will be rejected.
     *
     * You should therefore always check agent availability before starting a new conversation.
     * If no agents are available, only start conversations of the type {@link ConversationType.OFFLINE_CHAT_REQUEST}.
     *
     * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use [ui.openIndividualUi()]{@link UnbluUiApi.openIndividualUi} if this is needed.
     *
     * @param type The conversation type that shall be started.
     * @param visitorName The name the local visitor should have. This is only taken into account if the visitor is not already authenticated.
     * @param visitorData Custom data for the visitor in any format. **NOTE:** The data which is passed here could be used in [NewConversationCallback]{@link NewConversationInterceptor}
     * @param recipient The team or agent recipient of the conversation. This will overwrite any named area that might be set for this web page. **NOTE:** The data which is passed here could be used in [NewConversationCallback]{@link NewConversationInterceptor}
     * @return A promise that resolves to the conversation object giving API access to the started conversation.
     */
    startConversation(type: ConversationType, visitorName?: string, visitorData?: string, recipient?: NewConversationRecipient): Promise<Conversation>;
    /**
     * Set a custom interceptor which will be triggered when a new conversation is started (initiated from UI or JavaScript).
     * @param callback The interceptor which is called before a new conversation is started. The Callback is of type [NewConversationCallback]{@link NewConversationInterceptor}
     * @return A promise that resolves when the interceptor is successfully applied and active.
     */
    setNewConversationInterceptor(callback: NewConversationInterceptor): Promise<void>;
    /**
     * Joins an existing conversation with a given PIN.
     *
     * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use [ui.openIndividualUi()]{@link UnbluUiApi.openIndividualUi} if this is needed.
     *
     * @param pin The PIN retrieved from the Unblu Agent Desk.
     * @param visitorName The name the local visitor should have. This is only taken into account if the visitor is not already authenticated.
     * @return A promise that resolves to the conversation object giving API access to the joined conversation.
     */
    joinConversation(pin: string, visitorName?: string): Promise<Conversation>;
    /**
     * Opens the existing conversation with the given conversation ID.
     *
     * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use [ui.openIndividualUi()]{@link UnbluUiApi.openIndividualUi} if this is needed.
     *
     * @param conversationId The id of the conversation to be opened.
     * @return A promise that resolves to the conversation object giving API access to the opened conversation.
     */
    openConversation(conversationId: string): Promise<Conversation>;
    /**
     * Returns the currently active conversation or `null` if no conversation is active.
     *
     * **NOTE:** calling this method twice while the same conversation is active, will result in two individual conversation API instances being returned.
     * destroying one of them will not cause the other one to also be destroyed. If however the active conversation is closed, all returned Conversation instances will be destroyed.
     *
     * @return A promise that either resolves to the currently active conversation or `null` if no conversation is open.
     * @see {@link ACTIVE_CONVERSATION_CHANGE}
     */
    getActiveConversation(): Promise<Conversation | null>;
    /**
     * Returns all conversations of the current visitor. If no conversation is present, an empty array is returned.
     *
     * @return A promise that resolves to an array of [ConversationInfo]{@link ConversationInfo}.
     */
    getConversations(): Promise<ConversationInfo[]>;
    /**
     * Checks if an agent is available for the current named area and language.
     *
     * @return Promise that resolves to `true` if the availability state is [AVAILABLE]{@link AgentAvailabilityState.AVAILABLE} or [BUSY]{@link AgentAvailabilityState.BUSY}, `false` otherwise.
     * @see {@link getAgentAvailabilityState} for a more detailed check.
     */
    isAgentAvailable(): Promise<boolean>;
    /**
     * Returns the current availability state for the current named area and language.
     * @return Promise that resolves to the current availability state.
     * @see {@link isAgentAvailable} for a simpler check.
     */
    getAgentAvailabilityState(): Promise<AgentAvailabilityState>;
    private requireUpgrade;
    private onUpgraded;
    private assertNotDeinitialized;
    isDeinitialized(): Boolean;
    /**
     * De-initializes the API. It will destroy the UI, all connections and will release all resources (as far as it is technically possible).
     *
     * Afterwards the API can be initialized again via  {@link UnbluStaticApi.initialize | window.unblu.floating.api.initialize()}
     */
    deinitialize(): Promise<void>;
}
