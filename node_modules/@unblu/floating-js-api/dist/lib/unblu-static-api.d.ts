import { UnbluApi } from './unblu-api';
import { Listener } from './shared/internal/util/event-emitter';
import { ApiState } from "./shared/api-state";
import { Configuration } from "./shared/model/configuration";
import { UnbluFloatingApiFactory } from "./shared/internal/unblu-floating-api";
export { Configuration };
export type ReadyListener = (api: UnbluApi) => void;
export type ErrorListener = (e: Error) => void;
export type DeinitializingListener = () => void;
export type DeinitializedListener = () => void;
export type StateListener = (state: ApiState) => void;
/**
 * #### The central entry point that allows to configure an initialize the Unblu Floating JS API.
 * The Unblu Floating JS API is an optional add-on to the Unblu Floating UI.
 * The UnbluStaticApi works without actually loading the rest of Unblu.
 * It can do some general checks and load Unblu or connect the API to a loaded version of Unblu.
 *
 * Depending on how Unblu is integrated into the local website the API has to be initialized differently.
 *
 * **a.) API-only integration**
 * If no unblu-snippet is loaded into the page, the Unblu Floating UI can be fully initialized with the API.
 * In this case, both the `configure` and the `initialize` methods have to be called.
 * Example:
 * ```ts
 *  const api = await unblu.floating.api
 *      // configure the unblu server
 *      .configure({
 *          apiKey: "<your-api-key>",
 *          serverUrl: "<unblu-server-url>"
 *      })
 *      // initialize the api.
 *      .initialize();
 * ```
 * This implementation will load the Unblu snippet and initialize both the Unblu Floating UI and the JS API.
 *
 * **b.) Snippet and JS API integration**
 * If the Unblu snippet is already present in the local website, Unblu doesn't have to be loaded
 * and only the API has to be initialized.
 * Example:
 * ```ts
 * // directly initialize the api without configuring.
 * const api = await unblu.floating.api.initialize();
 *
 * ```
 */
export declare class UnbluStaticApi implements UnbluFloatingApiFactory {
    /**
     * Event emitted as soon as the API is initialized.
     *
     * It usually makes sense to use this event if there is some general action that has to be triggered when the API is initialized,
     * but there are several places in the integration code that may trigger the initialization.
     *
     * In most cases however, it is better to use
     * ```ts
     * unblu.floating.api.initialize().then(api => { //use api here });
     * ```
     * or
     * ```ts
     * let api = await unblu.floating.api.initialize();
     * // use api here
     * ```
     *
     * Note: that this event will be triggered again after each initialization.
     *
     * @event ready
     * @see {@link on} for listener registration
     */
    static readonly READY: 'ready';
    /**
     * Event emitted if the API initialization fails.
     *
     * It usually makes sense to use this event if there is some general action that has to be triggered when the API initialization fails,
     * but there are several places in the integration code that may trigger the initialization.
     *
     * In most cases however, it is better to use
     * ```ts
     * unblu.floating.api.initialize().catch(error=> { //handle error here });
     * ```
     * or
     * ```ts
     * try{
     *      let api = await unblu.floating.api.initialize();
     * }catch(e){
     *     // handle error here
     * }
     *
     * ```
     *
     * @event error
     * @see {@link on} for listener registration
     */
    static readonly ERROR: 'error';
    /**
     * Event emitted as soon as the API is going to get de-initialized.
     *
     * It usually makes sense to use this event to clean up resources and/or unregistering of listeners to no try to use the API again until it is initialized again.
     *
     * @event deinitializing
     * @see {@link on} for listener registration
     */
    static readonly DEINITIALIZING: 'deinitializing';
    /**
     * Event emitted as soon as the API is completely de-initialized.
     *
     * It usually makes sense to use this event to clean up resources and/or unregistering of listeners to no try to use the API again until it is initialized again.
     *
     * @event deinitialized
     * @see {@link on} for listener registration
     */
    static readonly DEINITIALIZED: 'deinitialized';
    /**
     * Event emitted whenever the API state changes
     *
     * @event state
     * @see {@link on} for listener registration
     */
    static readonly STATE: 'state';
    private state;
    private error;
    private eventEmitter;
    private configuration;
    private initializedApi;
    /**
     * @hidden
     */
    constructor();
    private static injectUnblu;
    /**
     * Registers an event listener for the given event.
     *
     * **Note** If the API is already initialized, this listener will be called directly.
     * @param event The ready event
     * @param listener The listener to be called.
     * @see {@link READY}
     */
    on(event: typeof UnbluStaticApi.READY, listener: ReadyListener): void;
    /**
     * Registers an event listener for the given event.
     *
     * **Note** If the API has already failed, this listener will be called directly.
     * @param event The error event
     * @param listener The listener to be called.
     * @see {@link ERROR}
     */
    on(event: typeof UnbluStaticApi.ERROR, listener: ErrorListener): void;
    /**
     * Registers an event listener for the given event.
     *
     * **Note** If the API is already deinitializing, this listener will be called directly.
     * @param event The deinitializing event
     * @param listener The listener to be called.
     * @see {@link DEINITIALIZING}
     */
    on(event: typeof UnbluStaticApi.DEINITIALIZING, listener: DeinitializingListener): void;
    /**
     * Registers an event listener for the given event.
     *
     * **Note** If the API is already deinitialized, this listener will be called directly.
     * @param event The deinitialized event
     * @param listener The listener to be called.
     * @see {@link DEINITIALIZED}
     */
    on(event: typeof UnbluStaticApi.DEINITIALIZED, listener: DeinitializedListener): void;
    /**
     * Registers an event listener for the given event.
     *
     * @param event The state event
     * @param listener The listener to be called.
     * @see {@link STATE}
     */
    on(event: typeof UnbluStaticApi.STATE, listener: StateListener): void;
    /**
     * Removes a previously registered listener.
     * @param event The event unregister.
     * @param listener The listener to be removed.
     * @return `true` if the listener was removed, `false` otherwise.
     */
    off(event: string, listener: Listener): boolean;
    /**
     * Checks whether the API has to be configured or not.
     *
     * - If no snippet is present and the API state is still [INITIAL]{@link ApiState.INITIAL} a configuration is necessary.
     * - If a snippet is present or the API is already loaded, configuration is not necessary.
     * - If the API state is in [DEINITIALIZED]{@link ApiState.DEINITIALIZED}
     *
     * @return `true` if a configuration is needed to initialize the API, `false` otherwise.
     * @see {@link configure} to configure the API
     * @see {@link initialize} to initialize the API
     */
    isConfigurationNeeded(): boolean;
    /**
     * Returns the current state of the API
     * @return the current API state.
     * @see {@link isInitialized} for a simpler check
     */
    getApiState(): ApiState;
    /**
     * Checks whether the API is initialized or not.
     * @return `true` if the API is initialized, `false` for any other state.
     * @see {@link getApiState} for the full state
     */
    isInitialized(): boolean;
    /**
     * Configures the way that Unblu should be initialized.
     *
     * The configuration of the Unblu API is needed when, and only when no Unblu snippet is already present in the website.
     *
     * **Note:**
     * - Calling this method when there's already an Unblu snippet will result in an {@link UnbluApiError}.
     * - This method must be called BEFORE {@link initialize}.
     * If it is called afterwards an {@link UnbluApiError} will be thrown.
     *
     * @param config The configuration to be set.
     * @return an instance of `this` allowing chaining like `unblu.floating.api.configure({...}).initialize();`
     * @see {@link isConfigurationNeeded} to check if configuration is needed or not.
     */
    configure(config: Configuration): UnbluStaticApi;
    /**
     * Initializes the API and resolves to the fully initialized API.
     *
     * If the API has already been initialized or is already in the initializing process, the existing API will be returned.
     * There is only ever one instance of the API which will be returned by any call of this method which makes it safe to call this multiple times.
     *
     * *The initialization may fail with a {@link UnbluApiError} for the following reasons*
     * - A configuration is needed but none was provided: [CONFIGURATION_MISSING]{@link UnbluErrorType.CONFIGURATION_MISSING}
     * - Loading Unblu encounters a problem: [ERROR_LOADING_UNBLU]{@link UnbluErrorType.ERROR_LOADING_UNBLU}
     * - The initialization timed out: [INITIALIZATION_TIMEOUT]{@link UnbluErrorType.INITIALIZATION_TIMEOUT}
     * - The Unblu API is incompatible with the Unblu server: [INCOMPATIBLE_UNBLU_VERSION]{@link UnbluErrorType.INCOMPATIBLE_UNBLU_VERSION}
     * - The browser is unsupported: [UNSUPPORTED_BROWSER]{@link UnbluErrorType.UNSUPPORTED_BROWSER}
     * - The provided access token is invalid: [AUTHENTICATION_FAILED]{@link UnbluErrorType.AUTHENTICATION_FAILED}
     */
    initialize(): Promise<UnbluApi>;
    private initializeApi;
    private handleError;
    private onDeinitializing;
    private onDeinitialized;
}
